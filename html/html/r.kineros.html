<html>
<head><!-- This document was created from RTF source by rtftohtml version 2.7.4 -->
<TITLE>Stamm.grassclip</TITLE>
</head><body>

<b>A GRASS Program for Determining the Topology of Stream Networks</b>
<p> <p> John F. Stamm<p> <p> 
Department of Geological Sciences, Case Western Reserve University, <p> 
Cleveland, OH  44106-7216, email:  jfs5@po.cwru.edu<p> 
<p> <b>Introduction</b>
<p> <p> This paper presents a GRASS (geographical resource analysis support 
system; Shapiro et al., 1992; United States Army Corps of Engineers, 1993) 
program for determining the topology of stream networks.  The program 
inputs raster files generated by the GRASS program <i>r.watershed</i>.  
Because it determines the relationships of tributary streams, it is 
called <i>r.tribs</i>.  The input files required are:<p> <p> 
<i>stream</i>: 	a raster map of stream segments; stream segments are 
labelled using integer values greater than or equal to 2,<p> 
<i>accumulation</i>: 	a raster map of the number of cells that 
drain through each cell; absolute values is the amount of overland 
flow that is routed through a pixel,<p> 
<i>drainage</i>:	a raster map of drainage directions; 
if there is no flow direction, a value  of -1 is assigned.  
Otherwise, the integers 1 through 8 are assigned to the compass 
directions shown below:<p> <p> <pre>


			5	 6	7
			4	-1	8	
			3	 2	1
</pre>

For example, a value of 2 means that the pixel drains south, a value of 
5 means the pixel drains to the northwest.<p> <p> Two tables are output 
by<i> r.tribs</i>.  The first table list the tributaries associated 
with each stream segment.  The second table list streams and tributaries 
in an order such that a stream and its tributaries are printed only if the 
tributaries have been previously listed.  That is, first order streams are 
listed first, streams with tributaries that are first order streams are 
listed second, and so on.  The program can also be run in debugging mode, 
in which more detailed information is printed.<p>
 <p> 
The program <i>r.tribs</i> was written so that GRASS can be used to 
generate input for a runoff and erosion model called KINEROS 
(Smith  et al., in press; Woolhiser et al., 1990).  KINEROS represents a 
watershed as a set of related elements.  Elements may be hillslopes, channels 
or ponds.  A computational order must be specified so that boundary 
conditions for an element, such as the amount of water contributed by 
lateral hillslopes and upstream tributaries, are available.  
The program <i>r.tribs</i> provides KINEROS with that computational order.<p> 
<p> <b>Input Files</b><p> <p> We assume that the program <i>r.watershed</i> 
has been run, and that the input files <i>stream</i>, <i>accumulation</i> 
and <i>drainage</i> are available. Assume these files are called <i>stream.0</i>, 
<i>accum.0</i> and <i>drain.0</i>, respectively.  The command-line version 
of r.tribs is:<p> <p> 	GRASS 4.1 &gt;  r.tribs st=stream.0 ac=accum.0 
dr=drain.0<p> <p> Alternately, the command <i>r.tribs</i> can be entered 
on the command line:<p> <p> 	
GRASS 4.1 &gt;  r.tribs<p> <p> and the user will be prompted for these 
files.<p> <p> <b>Methodology and Example of Output</b><p> <p> 
This is followed by a listing of the tributaries associated with each stream. 
The tributaries of a stream are determined by using the following methodology. 
<p> a. The <i>stream</i> and <i>accumulation</i> files are scanned to 
determine the locations of pixels that are stream segments and have the 
lowest accumulation of runoff for that segment.  These points mark the 
locations of the heads of the stream segments.  Locations of the head of a 
stream are stored for the next step.
<p> b.  Points within one pixel of the 
head are scanned to determine if they are part of a different stream segment 
and if they drain into the head of this stream.  The <i>drainage</i> raster 
file is used to determine the drainage direction.  Any point meeting this 
criteria are listed as tributary streams.
<p> c.  All points with no 
tributaries are first order.  Tributary values are set to zero.
<p> d.  The label of the stream and its tributaries are stored and printed 
to the screen.<p> <p> We have used<i> r.tribs</i> to generate output for 
a small watershed (17.5 km<sup>2</sup>) in Idaho (Horse Creek) in which 
we used <i>r.watershed</i> to define a total of 50 stream segments.  Note 
that stream segments and tributaries are labelled using even integers ranging 
from 2 to 102.  Stream segment 2 is located at the mouth of the watershed.  
<p> <p> The <i>r.tribs</i> program first outputs the number of rows 
(nrows) and columns (ncols) in the raster files.  Then the maximum and 
minimum labels of stream segments are printed.  This is followed by two 
tables.  The first table lists streams and their tributaries.  An example 
of this table is given below.<p> <p> 

<tt></tt><p> <tt>nrows: 138</tt>
<p> <tt>ncols: 273</tt><p> <tt></tt>
<p> <tt> Max stream index = 102</tt>
<p> <tt> Min stream index = 2</tt>
<p> <tt> Stream:    2    Tributary 0:    6    Tributary 1:    4    </tt>
<p> <tt> Stream:    4    Tributary 0:    0    Tributary 1:    0    </tt>
<p> <tt> Stream:    6    Tributary 0:   14    Tributary 1:    8    </tt>
<p> <tt> Stream:    8    Tributary 0:   12    Tributary 1:   10    </tt>
<p> <tt> Stream:   10    Tributary 0:    0    Tributary 1:    0    </tt>
<p> <tt> Stream:   12    Tributary 0:    0    Tributary 1:    0    </tt>
<p> <tt> Stream:   14    Tributary 0:   22    Tributary 1:   16    </tt>
<p> <tt> Stream:   16    Tributary 0:   20    Tributary 1:   18    </tt>
<p> <tt> Stream:   18    Tributary 0:    0    Tributary 1:    0    </tt>
<p> <tt> Stream:   20    Tributary 0:    0    Tributary 1:    0    </tt>
<p> <tt> Stream:   22    Tributary 0:  102    Tributary 1:   24    </tt>
<p> <tt> Stream:   24    Tributary 0:   36    Tributary 1:   26    </tt>
<p> <tt> Stream:   26    Tributary 0:   30    Tributary 1:   28    </tt>
<p> <tt> Stream:   28    Tributary 0:    0    Tributary 1:    0    </tt>
<p> <tt> Stream:   30    Tributary 0:   34    Tributary 1:   32    </tt>
<p> <tt> Stream:   32    Tributary 0:    0    Tributary 1:    0    </tt>
<p> <tt> Stream:   34    Tributary 0:    0    Tributary 1:    0    </tt>
<p> <tt> Stream:   36    Tributary 0:  100    Tributary 1:   38    </tt>
<p> <tt> Stream:   38    Tributary 0:   42    Tributary 1:   40    </tt>
<p> <tt> Stream:   40    Tributary 0:    0    Tributary 1:    0    </tt>
<p> <tt> Stream:   42    Tributary 0:   98    Tributary 1:   44    </tt>
<p> <tt> Stream:   44    Tributary 0:   96    Tributary 1:   46    </tt>
<p> <tt> Stream:   46    Tributary 0:   50    Tributary 1:   48    </tt>
<p> <tt> Stream:   48    Tributary 0:    0    Tributary 1:    0    </tt>
<p> <tt> Stream:   50    Tributary 0:   58    Tributary 1:   52    </tt><p> <tt> Stream:   52    Tributary 0:   56    Tributary 1:   54    </tt><p> <tt> Stream:   54    Tributary 0:    0    Tributary 1:    0    </tt><p> <tt> Stream:   56    Tributary 0:    0    Tributary 1:    0    </tt><p> <tt> Stream:   58    Tributary 0:   90    Tributary 1:   60    </tt><p> <tt> Stream:   60    Tributary 0:   88    Tributary 1:   62    </tt><p> <tt> Stream:   62    Tributary 0:   66    Tributary 1:   64    </tt><p> <tt> Stream:   64    Tributary 0:    0    Tributary 1:    0    </tt><p> <tt> Stream:   66    Tributary 0:   74    Tributary 1:   68    </tt><p> <tt> Stream:   68    Tributary 0:   72    Tributary 1:   70    </tt><p> <tt> Stream:   70    Tributary 0:    0    Tributary 1:    0    </tt><p> <tt> Stream:   72    Tributary 0:    0    Tributary 1:    0    </tt><p> <tt> Stream:   74    Tributary 0:   82    Tributary 1:   76    </tt><p> <tt> Stream:   76    Tributary 0:   80    Tributary 1:   78    </tt><p> <tt> Stream:   78    Tributary 0:    0    Tributary 1:    0    </tt><p> <tt> Stream:   80    Tributary 0:    0    Tributary 1:    0    </tt><p> <tt> Stream:   82    Tributary 0:   86    Tributary 1:   84    </tt><p> <tt> Stream:   84    Tributary 0:    0    Tributary 1:    0    </tt><p> <tt> Stream:   86    Tributary 0:    0    Tributary 1:    0    </tt><p> <tt> Stream:   88    Tributary 0:    0    Tributary 1:    0    </tt><p> <tt> Stream:   90    Tributary 0:   94    Tributary 1:   92    </tt><p> <tt> Stream:   92    Tributary 0:    0    Tributary 1:    0    </tt><p> <tt> Stream:   94    Tributary 0:    0    Tributary 1:    0    </tt><p> <tt> Stream:   96    Tributary 0:    0    Tributary 1:    0    </tt><p> <tt> Stream:   98    Tributary 0:    0    Tributary 1:    0    </tt><p> <tt> Stream:  100    Tributary 0:    0    Tributary 1:    0    </tt><p> <tt> Stream:  102    Tributary 0:    0    Tributary 1:    0    </tt><p> <tt></tt><p> If the program is run in debugging mode, then the values of <i>stream</i>, <i>accumulation</i> and <i>direction</i> of the head of the stream and the surrounding 8 pixels are also printed.  Set the value of <tt>DB_FIND_TRIBS</tt> (defined in the beginning of the routine <tt>find_tribs)</tt> to a value of <tt>1</tt> and recompile the program to activate debugging mode. <p> <p> The second table that is output by <i>r.tribs</i> list the streams and their associated tributaries in their proper computational order.  The program loops through the data listed above several times.  First streams with no tributaries are listed (<tt>LOOP 1</tt>).  Then streams with only first-order streams as tributaries are listed (<tt>LOOP 2</tt>).  Then, streams with tributaries listed in previous loops are listed.  The program continues until all streams have been listed.  The variable "<tt>Order</tt>" is also listed, which can be interpreted as the computational order.  This is the order in which programs, such as KINEROS, must consider streams in the network such that data for tributaries will be available when considering the listed stream.  An example listing of the computational order of streams is given below.<p> 

<tt></tt><p> <tt></tt><p> <tt> Computational Order of Stream Segments:</tt><p> <tt></tt><p> <tt> LOOP:   1</tt><p> <tt> Order:    0   Stream:   4   Tributary 0:   0   Tributary 1:   0</tt><p> <tt> Order:    1   Stream:  10   Tributary 0:   0   Tributary 1:   0</tt><p> <tt> Order:    2   Stream:  12   Tributary 0:   0   Tributary 1:   0</tt><p> <tt> Order:    3   Stream:  18   Tributary 0:   0   Tributary 1:   0</tt><p> <tt> Order:    4   Stream:  20   Tributary 0:   0   Tributary 1:   0</tt><p> <tt> Order:    5   Stream:  28   Tributary 0:   0   Tributary 1:   0</tt><p> <tt> Order:    6   Stream:  32   Tributary 0:   0   Tributary 1:   0</tt><p> <tt> Order:    7   Stream:  34   Tributary 0:   0   Tributary 1:   0</tt><p> <tt> Order:    8   Stream:  40   Tributary 0:   0   Tributary 1:   0</tt><p> <tt> Order:    9   Stream:  48   Tributary 0:   0   Tributary 1:   0</tt><p> <tt> Order:   10   Stream:  54   Tributary 0:   0   Tributary 1:   0</tt><p> <tt> Order:   11   Stream:  56   Tributary 0:   0   Tributary 1:   0</tt><p> <tt> Order:   12   Stream:  64   Tributary 0:   0   Tributary 1:   0</tt><p> <tt> Order:   13   Stream:  70   Tributary 0:   0   Tributary 1:   0</tt><p> <tt> Order:   14   Stream:  72   Tributary 0:   0   Tributary 1:   0</tt><p> <tt> Order:   15   Stream:  78   Tributary 0:   0   Tributary 1:   0</tt><p> <tt> Order:   16   Stream:  80   Tributary 0:   0   Tributary 1:   0</tt><p> <tt> Order:   17   Stream:  84   Tributary 0:   0   Tributary 1:   0</tt><p> <tt> Order:   18   Stream:  86   Tributary 0:   0   Tributary 1:   0</tt><p> <tt> Order:   19   Stream:  88   Tributary 0:   0   Tributary 1:   0</tt><p> <tt> Order:   20   Stream:  92   Tributary 0:   0   Tributary 1:   0</tt><p> <tt> Order:   21   Stream:  94   Tributary 0:   0   Tributary 1:   0</tt><p> <tt> Order:   22   Stream:  96   Tributary 0:   0   Tributary 1:   0</tt><p> <tt> Order:   23   Stream:  98   Tributary 0:   0   Tributary 1:   0</tt><p> <tt> Order:   24   Stream: 100   Tributary 0:   0   Tributary 1:   0</tt><p> <tt> Order:   25   Stream: 102   Tributary 0:   0   Tributary 1:   0</tt><p> <tt> -----------------------------------------------------------------</tt><p> 

<tt></tt><p> <tt> LOOP:   2</tt><p> <tt> Order:   26   Stream:   8   Tributary 0:  12   Tributary 1:  10</tt><p> <tt> Order:   27   Stream:  16   Tributary 0:  20   Tributary 1:  18</tt><p> <tt> Order:   28   Stream:  30   Tributary 0:  34   Tributary 1:  32</tt><p> <tt> Order:   29   Stream:  52   Tributary 0:  56   Tributary 1:  54</tt><p> <tt> Order:   30   Stream:  68   Tributary 0:  72   Tributary 1:  70</tt><p> <tt> Order:   31   Stream:  76   Tributary 0:  80   Tributary 1:  78</tt><p> <tt> Order:   32   Stream:  82   Tributary 0:  86   Tributary 1:  84</tt><p> <tt> Order:   33   Stream:  90   Tributary 0:  94   Tributary 1:  92</tt><p> <tt> -----------------------------------------------------------------</tt><p> <tt></tt><p> <tt> LOOP:   3</tt><p> <tt> Order:   34   Stream:  26   Tributary 0:  30   Tributary 1:  28</tt><p> <tt> Order:   35   Stream:  74   Tributary 0:  82   Tributary 1:  76</tt><p> <tt> -----------------------------------------------------------------</tt><p> 

<tt></tt><p> <tt> LOOP:   4</tt><p> <tt> Order:   36   Stream:  66   Tributary 0:  74   Tributary 1:  68</tt><p> <tt> -----------------------------------------------------------------</tt><p> <tt></tt><p> <tt> LOOP:   5</tt><p> <tt> Order:   37   Stream:  62   Tributary 0:  66   Tributary 1:  64</tt><p> <tt> -----------------------------------------------------------------</tt><p> <tt></tt><p> <tt> LOOP:   6</tt><p> <tt> Order:   38   Stream:  60   Tributary 0:  88   Tributary 1:  62</tt><p> <tt> -----------------------------------------------------------------</tt><p> <tt></tt><p> <tt> LOOP:   7</tt><p> <tt> Order:   39   Stream:  58   Tributary 0:  90   Tributary 1:  60</tt><p> <tt> -----------------------------------------------------------------</tt><p> <tt></tt><p> <tt> LOOP:   8</tt><p> <tt> Order:   40   Stream:  50   Tributary 0:  58   Tributary 1:  52</tt><p> <tt> -----------------------------------------------------------------</tt><p> <tt></tt><p> <tt> LOOP:   9</tt><p> <tt> Order:   41   Stream:  46   Tributary 0:  50   Tributary 1:  48</tt><p> <tt> -----------------------------------------------------------------</tt><p> <tt></tt><p> <tt> LOOP:  10</tt><p> <tt> Order:   42   Stream:  44   Tributary 0:  96   Tributary 1:  46</tt><p> <tt> -----------------------------------------------------------------</tt><p> <tt></tt><p> <tt> LOOP:  11</tt><p> <tt> Order:   43   Stream:  42   Tributary 0:  98   Tributary 1:  44</tt><p> <tt> -----------------------------------------------------------------</tt><p> <tt></tt><p> <tt> LOOP:  12</tt><p> <tt> Order:   44   Stream:  38   Tributary 0:  42   Tributary 1:  40</tt><p> <tt> -----------------------------------------------------------------</tt><p> <tt></tt><p> <tt> LOOP:  13</tt><p> <tt> Order:   45   Stream:  36   Tributary 0: 100   Tributary 1:  38</tt><p> <tt> -----------------------------------------------------------------</tt><p> <tt></tt><p> <tt> LOOP:  14</tt><p> <tt> Order:   46   Stream:  24   Tributary 0:  36   Tributary 1:  26</tt><p> <tt> -----------------------------------------------------------------</tt><p> <tt></tt><p> <tt> LOOP:  15</tt><p> <tt> Order:   47   Stream:  22   Tributary 0: 102   Tributary 1:  24</tt><p> <tt> -----------------------------------------------------------------</tt><p> <tt></tt><p> <tt> LOOP:  16</tt><p> <tt> Order:   48   Stream:  14   Tributary 0:  22   Tributary 1:  16</tt><p> <tt> -----------------------------------------------------------------</tt><p> <tt></tt><p> <tt> LOOP:  17</tt><p> <tt> Order:   49   Stream:   6   Tributary 0:  14   Tributary 1:   8</tt><p> <tt> -----------------------------------------------------------------</tt><p> <tt></tt><p> <tt> LOOP:  18</tt><p> <tt> Order:   50   Stream:   2   Tributary 0:   6   Tributary 1:   4</tt><p> <tt></tt><p> <tt></tt><p> 

<tt></tt><b>Obtaining r.tribs via FTP or email</b><p> <p> The C programs that are required to generate <i>r.tribs</i> are available via anonymous ftp to moon.cecer.army.mil.  I have printed out the main segment of the <i>r.tribs</i> program in Appendix I.  This was done to illustrate how routines in the GRASS library are used to read in raster data.  Routines from the GRASS library begin with <tt>"G_</tt>".  Two utility programs are also used: imatrix and ivector.  These are discussed by  Press and others (1989), and are used to allocate space for arrays.   Comments in the code discuss the details of each routine.  Appendix II lists the makefile used to compile <i>r.tribs</i>.  Note that the variable <tt>GIS</tt> must be edited so that the proper path to the grass directory is specified.<p> <p> As previously mentioned, the program can be obtained by anonymous ftp to moon.cecer.army.mil.  Change to the "incoming/r.tribs" directly to get the files.  The program can also be obtained by contacting the author via email (jfs5@po.cwru.edu).  The code has been commented to help the user to understand the program structure.<p> <p> <p> 



<b>References</b><p> <p> Press, W.H., Flannery, B.P., Teukolsky, S.A., and Vetterling, W.T., 1989, Numerical Recipes in C: The Art of Scientific Computing, Cambridge University Press, 735 pp.<p> <p> Shapiro, M., Westervelt, J., Gerdes, D., Larson, M., and Brownfield, K.R., 1992, GRASS 4.0 Programmer's Manual, U.S. Army Construction Engineering Research Laboratory, Champaign, Illinois, 292 pp.<p> <p> Smith, R.E., Goodrich, D.C., Woolhiser, D.A., and Unkrich, C.L., in press, A KINematic Runoff and EROSion Model, in: V.P. Singh (Ed.), Computer Models of Watershed Hydrology, Water Resources Pub., Highlands Ranch, Colorado<p> <p> United States Army Corps of Engineers, 1993, GRASS4.1 Users's Reference Manual, U.S. Army Construction Engineering Research Laboratories, Champaign, Illinois, 556 pp.<p> <p> Woolhiser, D.A., Smith, R.E., Goodrich, D.C., 1990, KINEROS, A Kinematic Runoff and Erosion Model: Documentation and Users Manual, U.S. Department of Agriculture, Agricultural Research Service, ARS-77, 130 pp.<p> <p>

 <b>Appendix I: main.c code for r.tribs</b><p> <p> <tt>#include "gis.h"</tt><p> <tt>#include &lt;stdio.h&gt;</tt><p> <tt></tt><p> <tt>int **imatrix();</tt><p> <tt>int  *ivector();</tt><p> <tt></tt><p> <tt>/*</tt><p> <tt> *  Program to determing the topology of a stream network.  A </tt><p> <tt> *  table is generated that reports the tributaries that are</tt><p> <tt> *  at the head of each stream segement. The computational order</tt><p> <tt> *  of streams is also determinted.</tt><p> <tt> *</tt><p> <tt> *  Written by:</tt><p> <tt> *  Dr. John F. Stamm</tt><p> <tt> *  Department of Geological Sciences</tt><p> <tt> *  Case Western Reserve University</tt><p> <tt> *  Cleveland, OH  44106-7216</tt><p> <tt> *  email: jfs5@po.cwru.edu</tt><p> <tt> */</tt><p> <tt></tt><p> <tt>main(argc,argv) </tt><p> <tt>int   argc;</tt><p> <tt>char *argv[];</tt><p> <tt>{</tt><p> <tt>/*</tt><p> <tt> *  Matricies</tt><p> <tt> */</tt><p> <tt>    int **accum;</tt><p> <tt>    int **chann;</tt><p> <tt>    int **aspect;</tt><p> <tt></tt><p> <tt>    CELL *cell;</tt><p> <tt></tt><p> <tt>    char *chann_name; </tt><p> <tt>    char *accum_name; </tt><p> <tt>    char *aspect_name; </tt><p> <tt>    char *mapset;</tt><p> <tt></tt><p> <tt>    int col;</tt><p> <tt>    int fd_accum;</tt><p> <tt>    int fd_chann;</tt><p> <tt>    int fd_aspect;</tt><p> <tt>    int ncols;</tt><p> <tt>    int nrows;</tt><p> <tt>    int row;</tt><p> <tt></tt><p> <tt>    struct {</tt><p> <tt>	struct Option *accum ;</tt><p> <tt>	struct Option *chann ;</tt><p> <tt>	struct Option *aspect ;</tt><p> <tt>    } parm;</tt><p> <tt></tt><p> <tt>/*</tt><p> <tt> *  Allocate memory for the Option structure and return a </tt><p> <tt> *  pointer to this structure.  Do this for the structured</tt><p> <tt> *  variables parm.accum and parm.chann.  </tt><p> 

<tt> *                        
</tt><p> <tt> *  Set values for parm.accum</tt><p> <tt> */</tt><p> <tt>    parm.accum = G_define_option() ;</tt><p> <tt>    parm.accum-&gt;key        = "accumulation";</tt><p> <tt>    parm.accum-&gt;type       = TYPE_STRING;</tt><p> <tt>    parm.accum-&gt;required   = YES;</tt><p> <tt>    parm.accum-&gt;gisprompt  = "old,cell,raster" ;</tt><p> <tt>    parm.accum-&gt;description= "Name of the ACCUMULATION map" ;</tt><p> <tt>/*</tt><p> <tt> *  Set values for parm.chann</tt><p> <tt> */</tt><p> <tt>    parm.chann = G_define_option() ;</tt><p> <tt>    parm.chann-&gt;key        = "stream";</tt><p> <tt>    parm.chann-&gt;type       = TYPE_STRING;</tt><p> <tt>    parm.chann-&gt;required   = YES;</tt><p> <tt>    parm.chann-&gt;gisprompt  = "old,cell,raster" ;</tt><p> <tt>    parm.chann-&gt;description= "Name of the STREAM map" ;</tt><p> <tt>/*</tt><p> <tt> *  Set values for parm.aspect</tt><p> <tt> */</tt><p> <tt>    parm.aspect = G_define_option() ;</tt><p> <tt>    parm.aspect-&gt;key        = "drainage";</tt><p> <tt>    parm.aspect-&gt;type       = TYPE_STRING;</tt><p> <tt>    parm.aspect-&gt;required   = YES;</tt><p> <tt>    parm.aspect-&gt;gisprompt  = "old,cell,raster" ;</tt><p> <tt>    parm.aspect-&gt;description= "Name of the DRAINAGE DIRECTION </tt><p> <tt>map";</tt><p> <tt></tt><p> <tt>/*</tt><p> <tt> *  Initailize GIS library for this program</tt><p> <tt> */</tt><p> <tt></tt><p> <tt>    G_gisinit(argv[0]);</tt><p> <tt></tt><p> <tt>/*</tt><p> <tt> *  Parse values from the command line.  If this is not</tt><p> <tt> *  successful, then display a usage statement and exit.</tt><p> <tt> */</tt><p> <tt></tt><p> <tt>    if (G_parser(argc, argv))</tt><p> <tt>       	exit (-1);</tt><p> <tt>    accum_name = parm.accum-&gt;answer;</tt><p> <tt>    chann_name = parm.chann-&gt;answer;</tt><p>
 
<tt>    aspect_name = parm.aspect-&gt;answer;</tt><p> <tt></tt><p> <tt>/*</tt><p> <tt> *  Find the name of mapset that we are going to use.</tt><p> <tt> */</tt><p> <tt></tt><p> <tt>    mapset = G_find_cell2 (accum_name, "");</tt><p> <tt></tt><p> <tt>    if (mapset == NULL) {</tt><p> <tt>        char msg[100];	</tt><p> <tt>	   sprintf (msg, "%s: &lt;%s&gt; cellfile not found\n",</tt><p> <tt>                 G_program_name(), accum_name);</tt><p> <tt>	   G_fatal_error (msg);</tt><p> <tt>        exit(1);</tt><p> <tt>    }</tt><p> <tt></tt><p> <tt>/*</tt><p> <tt> *  Open the cell files in "mapset".</tt><p> <tt> */</tt><p> <tt></tt><p> <tt>    fd_accum = G_open_cell_old (accum_name, mapset);</tt><p> <tt>    if (fd_accum &lt; 0)</tt><p> <tt>    	exit(1);</tt><p> <tt></tt><p> <tt>    fd_chann = G_open_cell_old (chann_name, mapset);</tt><p> <tt>    if (fd_chann &lt; 0)</tt><p> <tt>    	exit(1);</tt><p> <tt></tt><p> <tt>    fd_aspect = G_open_cell_old (aspect_name, mapset);</tt><p> <tt>    if (fd_aspect  &lt; 0)</tt><p> <tt>    	exit(1);</tt><p> <tt></tt><p> <tt>/*</tt><p> <tt> *  Open up a vector that is just long enough to hold one </tt><p> <tt> *  row of data.</tt><p> <tt> */</tt><p> <tt></tt><p> <tt>    cell = G_allocate_cell_buf();</tt><p> <tt></tt><p> <tt>/*</tt><p> <tt> *  Determine the number of rows and columns.</tt><p> <tt> */</tt><p> <tt></tt><p> <tt>    nrows = G_window_rows();</tt><p> <tt>    ncols = G_window_cols();</tt><p> <tt>    printf ("\n", nrows);</tt><p> <tt>    printf ("nrows: %d\n", nrows);</tt><p> <tt>    printf ("ncols: %d\n", ncols);</tt><p> <tt></tt><p> <tt>/*</tt><p> <tt> *  Allocate memory for matricies.</tt><p> <tt> */</tt><p> <tt></tt><p> <tt>    accum  = imatrix(0,nrows,0,ncols);</tt><p> <tt>    chann  = imatrix(0,nrows,0,ncols);</tt><p> <tt>    aspect = imatrix(0,nrows,0,ncols);</tt><p> <tt></tt><p> <tt>/*</tt><p> <tt> *  Process DEM and Channel files.</tt><p> <tt> */</tt><p> <tt></tt><p> <tt>    for (row=(nrows-1); row&gt;=0; row--) {</tt><p> <tt>	   if(G_get_map_row (fd_accum, cell, row) &lt; 0)</tt><p> <tt>	       exit(1);</tt><p> <tt>	   for (col = 0; col &lt; ncols; col++) {</tt><p> <tt>	       accum[row][col] = (int)cell[col];</tt><p> <tt>	   }</tt><p> <tt>	   if(G_get_map_row (fd_chann, cell, row) &lt; 0)</tt><p> <tt>	       exit(1);</tt><p> <tt>	   for (col = 0; col &lt; ncols; col++) {</tt><p> <tt>	       chann[row][col] = (int)cell[col];</tt><p> <tt>	   }</tt><p> <tt>	   if(G_get_map_row (fd_aspect, cell, row) &lt; 0)</tt><p> <tt>	       exit(1);</tt><p> <tt>	   for (col = 0; col &lt; ncols; col++) {</tt><p> <tt>	       aspect[row][col]  = (int)cell[col];</tt><p> <tt>	   }</tt><p> <tt>    }</tt><p> <tt></tt><p> <tt>/*</tt><p> <tt> *  Compute the topology of the network.</tt><p> <tt> */</tt><p> <tt></tt><p> <tt>    (void)find_tribs(nrows, ncols, accum, chann, aspect);</tt><p> <tt></tt><p> <tt>    exit(0);</tt><p> <tt>}</tt><p> <tt></tt><p> <tt></tt><p> <p> 


<b>Appendix II: Gmakefile</b><p> <p> <p> <tt>PGM    = r.tribs</tt><p> <tt>GIS    = /GRASS4.1</tt><p> <tt>HOME   = .</tt><p> <tt>SRC    = $(GIS)/src</tt><p> <tt>LIBDIR = $(SRC)/libes/LIB</tt><p> <tt>GISLIB = $(LIBDIR)/libgis.a</tt><p> <tt></tt><p> <tt>OFILES =	debug.o \</tt><p> <tt>		find_tribs.o \</tt><p> <tt>		imatrix.o \</tt><p> <tt>		ivector.o \</tt><p> <tt>		main.o \</tt><p> <tt>		neighbors.o \</tt><p> <tt>		stream_order.o</tt><p> <tt></tt><p> <tt>$(HOME)/$(PGM): $(OFILES) $(GISLIB)</tt><p> <tt>	$(CC) $(LDFLAGS) $(OFILES) $(GISLIB) -o $(PGM)</tt><p> <tt>$(GISLIB): #</tt><p> <tt></tt><p> <tt></tt><p> <tt></tt> </body></html>
