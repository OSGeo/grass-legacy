<HEAD>
<TITLE>GRASS 5.1 Vector Format and API</TITLE>
</HEAD>
<BODY>
<P>
<H1>GRASS 5.1 Vector Format and API</H1>

This document describes new format for <B>GRASS vector files</B> with 
<B>multicategory</B> and optional <B>3D</B> support.
<P>
You can send any comments to
<A href=mailto:ddgray@armadce.demon.co.uk>David D. Gray</A> and
<A href=mailto:blazek@itc.it>Radim Blazek</A>


<HR>

<H4><A HREF="#intro">Introduction</A></H4>
<H4><A HREF="#dir">Directory structure</A></H4>
<H4><A HREF="#coor">coor Format Specification</A></H4>
<H4><A HREF="#head">head Format Specification</A></H4>
<H4><A HREF="#topo">topo Format Specification</A></H4>
<H4><A HREF="#lib">Library</A></H4>
<H4><A HREF="#structures">New or Modified Constants, Structures, Functions</A></H4>
<H4><A HREF="#attr">Attributes</A></H4>
<H4><A HREF="#other">Other informations</A></H4>
<H4><A HREF="v.example.c">Example vector module</A></H4>
<H4><A HREF="v.modules.html">Vector Modules Status</A></H4>
<H4><A HREF="#ascii">Vector ascii Format Specification</A></H4>
<H4><A HREF="#options">Vector modules and options</A></H4>
<HR>

<H2><A NAME="intro">Introduction</A></H2>
<P>
New format is very similar to old GRASS vector format.
<P>
Each element may have none, one or more categories (cats).
More cats are distinguished by field number (field).
Only one cat with cat_num=1 will be used in first stage
and multi-category support on modules level will be added in
future.
<P>
Z-coordinate will be optional and both 2d and 3d files may
be written.


<HR>

<H2><A NAME="dir">Directory structure</A></H2>

Directory structure and file names are a bit changed.
All vector files for one vector map are stored in one
directory:<BR>
<B>$MAPSET/vector/vector_name/</B> <BR>
This directory contains these files:<BR><BR>
<B>coor</B> - binary file, coordinates, former dig/ file<BR>
<B>head</B> - text file, header information, former part of dig/<BR>
<B>topo</B> - binary file, topology, former dig_plus/<BR>
<B>misc</B> - miscellaneous - what's that?<BR>
<B>regi</B> - registration points <BR>

<HR>

<H2><A NAME="coor">coor Format Specification</A></H2>

<H3>Head</H3>
<TABLE border=2>
<TR><TD>Name</TD><TD>Type</TD><TD>Number</TD><TD>Description</TD></TR>

<TR><TD>Version_Major </TD><TD>C</TD><TD>1</TD><TD>&nbsp</TD></TR>
<TR><TD>Version_Minor </TD><TD>C</TD><TD>1</TD><TD>&nbsp</TD></TR>
<TR><TD>Earliest_Major</TD><TD>C</TD><TD>1</TD><TD>&nbsp</TD></TR>
<TR><TD>Earliest_Minor</TD><TD>C</TD><TD>1</TD><TD>&nbsp</TD></TR>

<TR><TD>byte_order</TD><TD>C</TD><TD>1</TD><TD>little or big endian flag;
                  files are written in machine native order but files
		  in both little and big endian order may be read</TD></TR>
<TR><TD>with_z</TD><TD>C</TD><TD>1</TD><TD>2D or 3D flag</TD></TR>
<TR><TD>size</TD><TD>L</TD><TD>1</TD><TD>coor file size</TD></TR>
<TR><TD>reserved</TD><TD>C</TD><TD>10</TD><TD>not used</TD></TR>

</TABLE>

<H3>Body</H3>

The body consists of line records:
<BR>

<TABLE border=2>
<TR><TD>Name</TD><TD>Type</TD><TD>Number</TD><TD>Description</TD></TR>
<TR><TD>record header</TD><TD>I</TD><TD>1</TD><TD>
<UL>
  <LI><B>0. bit</B> : 1 - alive, 0 - dead line
  <LI><B>1. bit</B> : 1 - categories, 0 - no categories
  <LI><B>2.-3. bit</B> : type - one of: GV_POINT, GV_LINE, 
                              GV_BOUNDARY, GV_CENTROID
  <LI><B>4.-7. bit</B> : reserved, not used 
<UL>
</TD></TR>
<TR><TD>ncats</TD><TD>C</TD><TD>1</TD><TD>number of categories 
    (written only if categories exist) </TD></TR>
<TR><TD>field</TD><TD>S</TD><TD>ncats</TD><TD>Category identifier, 
    distinguishes between more categories append to one line 
    (written only if categories exist)</TD></TR>
<TR><TD>cat</TD><TD>I</TD><TD>ncats</TD><TD>category value 
    (written only if categories exist)</TD></TR>
<TR><TD>ncoor</TD><TD>I</TD><TD>1</TD><TD>written for GV_LINES and GV_BOUNDARIES 
    only</TD></TR>
<TR><TD>x</TD><TD>D</TD><TD>ncoor</TD><TD>&nbsp</TD></TR>
<TR><TD>y</TD><TD>D</TD><TD>ncoor</TD><TD>&nbsp</TD></TR>
<TR><TD>z</TD><TD>D</TD><TD>ncoor</TD><TD>present if with_z in head 
    is set to 1</TD></TR>
</TABLE>


<BR>
<B>Types used in coor file</B>
<TABLE border=2>
<TR><TD>Type</TD><TD>Name</TD><TD>Size in Bytes</TD></TR>
<TR><TD>D</TD><TD>Double</TD><TD>8</TD></TR>
<TR><TD>L</TD><TD>Long  </TD><TD>4</TD></TR>
<TR><TD>I</TD><TD>Int   </TD><TD>4</TD></TR>
<TR><TD>S</TD><TD>Short </TD><TD>4</TD></TR>
<TR><TD>C</TD><TD>Char  </TD><TD>1</TD></TR>
</TABLE>

<HR>

<H2><A NAME="head">head file format</A></H2>

The file is unordered list of key/value entries. The <I>key</I>
is a string separated from <I>value</I> by a colon and optional
whitespace. Key words are:<BR>
<PRE>
ORGANIZATION
DIGIT DATE
DIGIT NAME
MAP NAME
MAP DATE
MAP SCALE
OTHER INFO
ZONE
MAP THRESH
</PRE>
<HR>

<H2><A NAME="topo">topo file format</A></H2>

Is not defined yet. 

<HR>

<H2><A NAME="lib">Library</A></H2>

For historical reasons, there are two libraries for vector: <BR><BR>

diglib, dig_*(), DIGLIB, libdig.a, digit library, grass3.x, 4.x<BR>
and<BR>
Vlib, Vect_*(), VECTLIB_REAL, libvect.a, vector library, grass4.x<BR><BR>

Vector library was introduced in grass4.0 to hide vector files' formats
and structures. However in grass5.0 modules often access dig_plus structure
directly. We want to go on in hiding structures and replace for example:
<PRE>
    xx = Map.Att[Map.Area[area_num].att].x;
</PRE>by new function<PRE>
    V2_get_area_centroid()
</PRE>
Some functions used by modules in grass5.0 are still in Digit library and often cause
circular references because depend on Vector library (VECTLIB must be used twice in Gmakefile). 
These functions will be moved to Vector library and renamed from dig_*() to Vect_()
(for example dig_point_to_area(), dig_point_in_area()).
<P>

As result of these changes there will be <i>common modules</i> which will
access data only through these Vect_*() functions. Common modules are
modules which do not write directly to the topology file i.e. neither build
topology nor update files on level2. They can read vector maps on level 1 or
level 2 but writes into the coor file (geometry) on level1 only.
<P>
But there are few <I>special modules</I> v.build, v.digit (more?) which must
write into topo file. The v.build module will we probably replaced by
Vect_build() function??? v.digit will continue too use dig_*() functions for
direct access to topology file at least in grass5.1 or in the beginning of
grass5.1.

<HR>

<H2><A NAME="structures">New or Modified Constants, Structures, Functions</A></H2>
<PRE>
#define GV_POINT		0x01   
#define GV_LINE			0x02 
#define GV_BOUNDARY		0x04
#define GV_CENTROID		0x08

struct line_cats
  {
      int *field;	/* pointer to array of fields */
      int *cat;		/* pointer to array of categories */
      int n_cats;	/* number of vector categories attached to element */
      int alloc_cats;	/* allocated space */
  };

int Vect_open_new (struct Map_info *, char name *, int with_z);
long Vect_write_line (struct Map_info *, int type, struct line_pnts *, struct line_cats *);
int Vect_read_next_line (struct Map_info *, struct line_pnts *, struct line_cats *);
struct line_cats *Vect_new_cats_struct (void); 
int Vect_reset_cats (struct line_cats *);
int Vect_destroy_cats_struct (struct line_cats *); 
int Vect_cat_set (struct line_cats *, int, int);
int Vect_cat_get (struct line_cats *, int, int *);
int Vect_cat_del (struct line_cats *, int);
int Vect_reset_cats (struct line_cats *);

</PRE>

<HR>

<H2><A NAME="attr">Attributes</A></H2>

dig_cats files are not used any more and
vectors' attributes are stored in external database.
Connection with database is done through drivers based on DBMI library
(odbc, dbf, informix drivers are available at this time). Records in table
are linked to vector entities by field and category number. 
The field identifies table and the category identifies record.
I.e. for unique combination map+mapset+field+category exists one
unique combination driver+database+table+row.
<P>
For each pair <B>map + field</B> must be defined <B>table, key column,
database, driver</B>. This definition must be written to $MAPSET/DB text file.
Each row in DB file contains names separated by spaces in following order
([] - optional): <BR><BR>

<B>map[@mapset] field table [key [database [driver]]] </B><BR><BR>

Please don't cry: "I don't need that, that is too complex!". If it
realy is, you can survive with just one row from example nr. 1,
but there are people who need more features in one map.
<P>
If key, database or driver are omited (on second and higher row only)
last definition is used. Definition from DB file in other mapset
may be overwritten by definition in current mapset if mapset is specified 
with map name.
<P>
Wild cards <B>*</B> and <B>?</B> may be used in map and mapset names.
<P>
Variables <B>$GISDBASE, $LOCATION, $MAPSET, $MAP, $FIELD</B>
may be used in table, key, database and driver names. Note that
$MAPSET is not current mapset but mapset of the map the rule is defined for.

<P>
<H3>Examples:</H3>
Examples are written mostly for dbf driver where database is full path to
directory with dbf files and table name is name of dbf file without
.dbf extension.
<P>
<PRE><B>* 1 tbl id $GISDBASE/$LOCATION/$MAPSET/vector/$MAP dbf</B></PRE>
This definition says that entities with category of field 1 are linked
to dbf tables with names tbl.dbf saved in vector directories of each map.<BR><BR>

<PRE><B>* 1 $MAP id $GISDBASE/$LOCATION/$MAPSET/dbf dbf</B></PRE> 
Similar as above but all dbf files are in one directory dbf/ in mapset
and names of dbf files are $MAP.dbf<BR><BR>

<PRE><B>water* 1 rivers id /home/grass/dbf dbf</B>
<B>water* 2 lakes lakeid /home/guser/mydb</B>
<B>trans* 1 roads key basedb odbc</B>
<B>trans* 5 rails</B></PRE>
These definitions defines more fields for one map i.e. in one map may be more
features linked to more tables. Definition on first 2 rows are applied for example
on maps water1, water2, ... so that more maps may share one table.<BR><BR>

<PRE><B>water@PERMANENT 1 myrivers id /home/guser/mydbf dbf</B></PRE>
This definion overwrites definition saved in PERMANENT/DB and 
links map from PERMANENT mapset to user's table.<BR><BR>

<P>
Modules should be written so that connections to database for each
vector field are independent. It should be possible to read attributes
of input map from one database and write to some other and even with
some other driver (should not be such problem). 

<P>
There are open questions however. For example how to distinguish when
new table should be written and when not. For example definitions:<BR>
river 1 river id water odbc<BR>
river.backup* 1 NONE<BR>
could be used to say that tables should not be copied for backups of
map river because table is stored in reliable RDBMS. 

<P>
Remarks are welcome.


<HR>

<H2><A NAME="other">Other Informations</A></H2>
<P>
Bounding box information was moved from coor file to topo file.

<HR>

<H2><A NAME="ascii">Vector ascii Format Specification</A></H2>
<P>
Ascii format in new version contains categories, new type
centroid and z-coordinates. Points and centroids are saved 
as one coordinates pair instead of two. File is saved
in old dig_ascii directory but the name will be probably changed.

<H3>Head</H3>
The head of the file is similar as the head file of vector binary
format but contains bounding box also. Key words are:<BR>
<PRE>
ORGANIZATION
DIGIT DATE
DIGIT NAME
MAP NAME
MAP DATE
MAP SCALE
OTHER INFO
ZONE
WEST EDGE
EAST EDGE
SOUTH EDGE
NORTH EDGE
MAP THRESH
</PRE>

<H3>Body</H3>
The body begins by row:
<PRE>
VERTI:
</PRE>
followed by records of lines:
<PRE>
TYPE NUMBER_OF_COORDINATES [NUMBER_OF_CATEGORIES]
 Y X [Z]
....
 Y X [Z]
[ FIELD CATEGORY]
....
[ FIELD CATEGORY]
</PRE>
Everything in <B>[]</B> is optional. 
TYPE may be:<BR><BR>
<B>P</B> point (dot) <BR> 
<B>p</B> dead point (dead dot) <BR> 
<B>L</B> line  <BR>
<B>l</B> dead line <BR> 
<B>B(A)</B> boundary  <BR>
<B>b(a)</B> dead boundary  <BR>
<B>C</B> centroid  <BR>
<B>c</B> dead centroid  <BR>

<BR>
Example of records:
<PRE>
P 1 1
 1234 3435
 1 354
L 3 1
 4132 4534
 1453 1454
 1453 4543
 1 355
</PRE>

<HR>

<H2><A NAME="options">Vector modules and options</A></H2>

See also grass5/documents/parameter_proposal.txt

<H3>Operation</H3>
Each module which modifies and writes data must read from input= and
write to output= so that data may not be lost. For example v.spag
works on map= at in grass5.0 but if program (system) crashes or treshold was 
specified incorrectly and vector was not backuped, data are lost. 
In this case map= option should be replaced by input= and output=
<P>
Topology is always build by default if coor file was modified.
<P>
Dimension is kept. Input 2D vector is written as 2D, 3D as 3D.

<H3>Options</H3>
<B>-f</B> overwrite existing files, default <BR>
<B>-i</B> ask user before overwriting existing files <BR>
<B>-b</B> do not build topo file; topo file is written by default <BR>
<B>-q</B> quiet <BR>
<B>-v</B> run verbosely <BR>
<B>-t</B> create new table, default ??? <BR>
<B>-u</B> don't create new table ??? <BR>
<B>-z</B> write 3D file (if input was 2D) <BR>
<BR>
<B>map=</B> input vector for modules without output <BR>
<B>input=</B> input vector <BR>
<B>output=</B> output vector <BR>
<B>type=</B>  type of elements:  point,line,boundary,centroid,area <BR>
<B>cat=</B> category or category list (example: 1,5,9-13,35) <BR>
<B>field=</B> field number <BR>
<B>where=</B> condition of SQL statement for selection of records <BR>
<B>col=</B> column name (in external table) <BR>

</BODY>
</HTML>

